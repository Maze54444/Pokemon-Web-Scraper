"""
Modul zur webseitenspezifischen Verf√ºgbarkeitspr√ºfung

Dieses Modul stellt Funktionen bereit, um die Verf√ºgbarkeit von Produkten
auf verschiedenen Webseiten zu erkennen. Jede Webseite hat ihre eigenen
Indikatoren und Muster, die hier implementiert werden.
"""

import re
from bs4 import BeautifulSoup

def detect_availability(soup, url):
    """
    Erkennt die Verf√ºgbarkeit eines Produkts basierend auf der Website-URL
    
    :param soup: BeautifulSoup-Objekt der Produktseite
    :param url: URL der Produktseite
    :return: Tuple (is_available, price, status_text)
    """
    domain = extract_domain(url)
    
    # Website-spezifische Funktionen aufrufen
    if "comicplanet.de" in domain:
        return check_comicplanet(soup)
    elif "kofuku.de" in domain:
        return check_kofuku(soup)
    elif "tcgviert.com" in domain:
        return check_tcgviert(soup)
    elif "card-corner.de" in domain:
        return check_card_corner(soup)
    elif "sapphire-cards.de" in domain:
        return check_sapphire_cards(soup)
    elif "mighty-cards.de" in domain:
        return check_mighty_cards(soup)
    elif "games-island.eu" in domain:
        return check_games_island(soup)
    elif "gameware.at" in domain:
        return check_gameware(soup)
    else:
        # Generische Erkennung f√ºr nicht speziell implementierte Websites
        return check_generic(soup)

def extract_domain(url):
    """Extrahiert die Domain aus einer URL"""
    match = re.search(r'https?://(?:www\.)?([^/]+)', url)
    return match.group(1) if match else url

def extract_price(soup, selectors=None):
    """
    Extrahiert den Preis aus der Produktseite
    
    :param soup: BeautifulSoup-Objekt der Produktseite
    :param selectors: Liste von CSS-Selektoren f√ºr den Preis (optional)
    :return: Formatierter Preis oder Standardtext
    """
    # Standardselektoren, falls keine spezifischen angegeben sind
    if selectors is None:
        selectors = [
            '.price', '.product-price', '.woocommerce-Price-amount', 
            '[itemprop="price"]', '.product__price', '.price-item',
            '.current-price', '.product-single__price', '.product-price-box',
            '.main-price', '.price-box', '.offer-price', '.price-regular'
        ]
    
    # Versuche, Preis mit verschiedenen Selektoren zu finden
    for selector in selectors:
        price_elem = soup.select_one(selector)
        if price_elem:
            price_text = price_elem.get_text().strip()
            # Bereinige Preis
            price_text = re.sub(r'\s+', ' ', price_text)
            return price_text
    
    # Wenn kein strukturiertes Element gefunden wurde, versuche Regex
    page_text = soup.get_text()
    price_patterns = [
        r'(\d+[,.]\d+)\s*[‚Ç¨$¬£]',  # 19,99 ‚Ç¨ oder 19.99 ‚Ç¨
        r'[‚Ç¨$¬£]\s*(\d+[,.]\d+)',  # ‚Ç¨ 19,99 oder ‚Ç¨ 19.99
        r'(\d+[,.]\d+)',          # Nur Zahl als letzter Versuch
    ]
    
    for pattern in price_patterns:
        match = re.search(pattern, page_text)
        if match:
            return f"{match.group(1)}‚Ç¨"
    
    return "Preis nicht verf√ºgbar"

def check_comicplanet(soup):
    """
    Pr√ºft die Verf√ºgbarkeit auf comicplanet.de
    
    Verf√ºgbare Produkte:
    - Blaue "In den Warenkorb"-Schaltfl√§che
    
    Nicht verf√ºgbare Produkte:
    - Roter Text "Nicht mehr verf√ºgbar"
    - Oranger Benachrichtigungsbereich
    """
    # Pr√ºfe auf "Nicht mehr verf√ºgbar"-Text
    unavailable_text = soup.find(string=re.compile("Nicht mehr verf√ºgbar", re.IGNORECASE))
    if unavailable_text:
        price = extract_price(soup, ['.price', '.product-price'])
        return False, price, "‚ùå Ausverkauft (Nicht mehr verf√ºgbar)"
    
    # Pr√ºfe auf Benachrichtigungselement
    notify_element = soup.select_one('.product-notify-form, .form-notify-me')
    if notify_element:
        price = extract_price(soup, ['.price', '.product-price'])
        return False, price, "‚ùå Ausverkauft (Benachrichtigungsoption vorhanden)"
    
    # Pr√ºfe auf "In den Warenkorb"-Button
    cart_button = soup.find('button', string=re.compile("In den Warenkorb", re.IGNORECASE))
    if cart_button:
        price = extract_price(soup, ['.price', '.product-price'])
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Button vorhanden)"
    
    # Fallback: Pr√ºfe auf "Details"-Button statt Kaufoption
    details_button = soup.find('button', string=re.compile("Details", re.IGNORECASE))
    if details_button:
        price = extract_price(soup, ['.price', '.product-price'])
        return False, price, "‚ùå Ausverkauft (Nur Details-Button)"
    
    # Wenn keine der bekannten Muster zutrifft, generische Methode
    return check_generic(soup)

def check_kofuku(soup):
    """
    Verbesserte Pr√ºfung der Verf√ºgbarkeit auf kofuku.de
    
    Verf√ºgbare Produkte:
    - "IN DEN WARENKORB"-Button ist aktiv und nicht ausgegraut
    - Kein Ausverkauft-Text oder -Badge
    
    Nicht verf√ºgbare Produkte:
    - Ausverkauft-Badge oder ausgegrauer "AUSVERKAUFT"-Button
    - Schloss-Symbol
    """
    # Extrahiere den Preis
    price = extract_price(soup, ['.price', '.product-price', '.product__price'])
    page_text = soup.get_text().lower()
    
    # WICHTIG: Pr√ºfe zuerst auf eindeutige Verf√ºgbarkeitsindikatoren
    
    # 1. Pr√ºfe auf einen aktiven "In den Warenkorb"-Button
    # Dies ist ein sehr starker Indikator f√ºr Verf√ºgbarkeit bei Kofuku
    cart_button = soup.find('button', string=re.compile("In den Warenkorb", re.IGNORECASE))
    if cart_button and 'disabled' not in cart_button.get('class', []) and 'disabled' not in cart_button.attrs:
        print(f"  üîç Kofuku: Aktiver 'In den Warenkorb'-Button gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Button aktiv)"
    
    # 2. Pr√ºfe auf "Buy Now"-Button oder √§hnliche Kaufoptionen
    buy_button = soup.select_one('.btn-buy, .buy-now, .add-to-cart:not(.disabled)')
    if buy_button:
        print(f"  üîç Kofuku: Kauf-Button gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Kauf-Button vorhanden)"
    
    # Jetzt erst auf Nicht-Verf√ºgbarkeit pr√ºfen
    
    # 3. Pr√ºfe auf "Ausverkauft"-Text
    sold_out_text = soup.find(string=re.compile("Ausverkauft", re.IGNORECASE))
    if sold_out_text:
        print(f"  üîç Kofuku: 'Ausverkauft'-Text gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Text gefunden)"
    
    # 4. Pr√ºfe auf ausgegraut/deaktivierte Buttons
    disabled_button = soup.select_one('button.disabled, button[disabled], .btn--sold-out')
    if disabled_button:
        print(f"  üîç Kofuku: Deaktivierter Button gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Button deaktiviert)"
    
    # 5. Pr√ºfe auf Schloss-Symbol (oft bei ausverkauften Produkten)
    lock_icon = soup.select_one('.icon-lock, .sold-out-overlay')
    if lock_icon:
        print(f"  üîç Kofuku: Schloss-Symbol gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Schloss-Symbol vorhanden)"
    
    # 6. Pr√ºfe auf "ausverkauft" im Text der Seite
    if "ausverkauft" in page_text:
        print(f"  üîç Kofuku: 'ausverkauft' im Seitentext gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Text im Seiteninhalt)"
    
    # Wenn keine der bekannten Muster zutrifft, generische Methode
    print(f"  üîç Kofuku: Keine eindeutigen Indikatoren gefunden, verwende generische Methode", flush=True)
    return check_generic(soup)

def check_tcgviert(soup):
    """
    Pr√ºft die Verf√ºgbarkeit auf tcgviert.com
    
    Verf√ºgbare Produkte:
    - Schwarze "IN DEN EINKAUFSWAGEN LEGEN"-Schaltfl√§che
    
    Nicht verf√ºgbare Produkte:
    - Grauer Kreis mit "AUSVERKAUFT"
    - Schwarze Schaltfl√§che mit "BEI VERF√úGBARKEIT INFORMIEREN!"
    """
    # Pr√ºfe auf "AUSVERKAUFT"-Text auf der Seite
    sold_out_text = soup.find(string=re.compile("AUSVERKAUFT", re.IGNORECASE))
    if sold_out_text:
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return False, price, "‚ùå Ausverkauft (AUSVERKAUFT-Text gefunden)"
    
    # Pr√ºfe auf Benachrichtigungsbutton
    notify_button = soup.find('button', string=re.compile("BEI VERF√úGBARKEIT INFORMIEREN", re.IGNORECASE))
    if notify_button:
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return False, price, "‚ùå Ausverkauft (Benachrichtigungsbutton vorhanden)"
    
    # Pr√ºfe auf Einkaufswagen-Button
    cart_button = soup.find('button', string=re.compile("IN DEN EINKAUFSWAGEN LEGEN", re.IGNORECASE))
    if cart_button:
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return True, price, "‚úÖ Verf√ºgbar (Einkaufswagen-Button vorhanden)"
    
    # Pr√ºfe auf "sold out"-Klassen
    sold_out_classes = soup.select_one('.sold-out, .sold_out, .product-tag--sold-out')
    if sold_out_classes:
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return False, price, "‚ùå Ausverkauft (Ausverkauft-Klasse gefunden)"
    
    # Wenn keine der bekannten Muster zutrifft, generische Methode
    return check_generic(soup)

def check_card_corner(soup):
    """
    Verbesserte Pr√ºfung der Verf√ºgbarkeit auf card-corner.de
    
    Verf√ºgbare Produkte:
    - Gr√ºner Status "Verf√ºgbar"
    - Gr√ºner "In den Warenkorb" Button
    - Produkt mit gr√ºner Umrandung
    
    Nicht verf√ºgbare Produkte:
    - AUSVERKAUFT-Badge
    - Roter Status "Momentan nicht verf√ºgbar"
    """
    # Extrahiere den Preis
    price = extract_price(soup, ['.price', '.product-price', '.product__price'])
    page_text = soup.get_text().lower()
    
    # WICHTIG: Pr√ºfe zuerst auf eindeutige Nicht-Verf√ºgbarkeitsindikatoren
    # 1. Pr√ºfe auf "Momentan nicht verf√ºgbar" oder "Ausverkauft" Text
    unavailable_text = soup.find(string=re.compile("(Momentan nicht verf√ºgbar|Ausverkauft|Artikel ist leider nicht)", re.IGNORECASE))
    if unavailable_text:
        print(f"  üîç Card-Corner: 'Nicht verf√ºgbar'-Text gefunden: {unavailable_text}", flush=True)
        return False, price, "‚ùå Ausverkauft (Text gefunden)"
    
    # 2. Pr√ºfe auf ausverkauft Badge oder Element
    soldout_elem = soup.select_one('.sold-out, .badge-danger, .out-of-stock')
    if soldout_elem:
        print(f"  üîç Card-Corner: Ausverkauft-Badge gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Badge gefunden)"
    
    # 3. Pr√ºfe auf deaktivierte Buttons
    disabled_button = soup.select_one('button[disabled], .btn.disabled, .add-to-cart.disabled')
    if disabled_button:
        print(f"  üîç Card-Corner: Deaktivierter Button gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Button deaktiviert)"
        
    # Jetzt erst auf Verf√ºgbarkeit pr√ºfen
    
    # 4. Pr√ºfe auf Verf√ºgbar-Text
    available_text = soup.find(string=re.compile("(Verf√ºgbar|Auf Lager|Sofort lieferbar)", re.IGNORECASE))
    if available_text:
        print(f"  üîç Card-Corner: 'Verf√ºgbar'-Text gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Verf√ºgbar-Text)"
    
    # 5. Pr√ºfe auf aktiven Warenkorb-Button
    cart_button = soup.select_one('.btn-primary:not([disabled]), .add-to-cart:not(.disabled), .btn-success')
    if cart_button:
        print(f"  üîç Card-Corner: Aktiver Warenkorb-Button gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Button aktiv)"
    
    # Wenn nichts eindeutiges gefunden wurde, nimm als Defaultwert nicht verf√ºgbar
    print(f"  üîç Card-Corner: Keine eindeutigen Indikatoren gefunden, nehme 'nicht verf√ºgbar' als Default", flush=True)
    return False, price, "‚ùå Ausverkauft (keine Verf√ºgbarkeitsindikatoren gefunden)"

def check_sapphire_cards(soup):
    """
    Pr√ºft die Verf√ºgbarkeit auf sapphire-cards.de
    
    Verf√ºgbare Produkte:
    - Blauer "In den Warenkorb"-Button
    - Gr√ºner Rahmen um die Sprachflagge
    
    Nicht verf√ºgbare Produkte:
    - Roter "In den Warenkorb"-Button
    """
    # Pr√ºfe auf roten "In den Warenkorb"-Button (nicht verf√ºgbar)
    red_cart_button = soup.select_one('button.btn-danger, button.btn-outline-danger, .btn-cart.unavailable')
    if red_cart_button:
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return False, price, "‚ùå Ausverkauft (Roter Warenkorb-Button)"
    
    # Pr√ºfe auf blauen "In den Warenkorb"-Button (verf√ºgbar)
    blue_cart_button = soup.select_one('button.btn-primary, button.btn-outline-primary, .btn-cart:not(.unavailable)')
    if blue_cart_button:
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return True, price, "‚úÖ Verf√ºgbar (Blauer Warenkorb-Button)"
    
    # Pr√ºfe auf aktive Sprachauswahl mit gr√ºnem Rahmen
    lang_selection = soup.select_one('.lang-selection.active, .flag-container.selected')
    if lang_selection:
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return True, price, "‚úÖ Verf√ºgbar (Aktive Sprachauswahl)"
    
    # Pr√ºfe auf "In den Warenkorb"-Text (als zus√§tzlichen Indikator)
    cart_text = soup.find(string=re.compile("In den Warenkorb", re.IGNORECASE))
    if cart_text and not red_cart_button:
        # Wenn wir Warenkorb-Text haben, aber keinen roten Button, ist es wahrscheinlich verf√ºgbar
        price = extract_price(soup, ['.price', '.product-price', '.product__price'])
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Text)"
    
    # Wenn keine der bekannten Muster zutrifft, generische Methode
    return check_generic(soup)

def check_mighty_cards(soup):
    """
    Pr√ºft die Verf√ºgbarkeit auf mighty-cards.de
    
    Verf√ºgbare Produkte:
    - Statusindikator: NEW, SALE oder EXCLUSIVE
    - Roter "In den Warenkorb"-Button
    
    Nicht verf√ºgbare Produkte:
    - Roter Button mit "AUSVERKAUFT"
    - Kein "In den Warenkorb"-Button
    """
    # Pr√ºfe auf "AUSVERKAUFT"-Text
    sold_out_text = soup.find(string=re.compile("AUSVERKAUFT", re.IGNORECASE))
    if sold_out_text:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return False, price, "‚ùå Ausverkauft (AUSVERKAUFT-Text)"
    
    # Pr√ºfe auf "In den Warenkorb"-Button
    cart_button = soup.find('button', string=re.compile("In den Warenkorb", re.IGNORECASE))
    if cart_button:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Button)"
    
    # Pr√ºfe auf spezielle Statusanzeigen, die auf Verf√ºgbarkeit hindeuten
    special_status = soup.find(string=re.compile("NEW|SALE|EXCLUSIVE", re.IGNORECASE))
    if special_status:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return True, price, f"‚úÖ Verf√ºgbar ({special_status.strip()})"
    
    # Wenn keine der bekannten Muster zutrifft, generische Methode
    return check_generic(soup)

def check_games_island(soup):
    """
    Pr√ºft die Verf√ºgbarkeit auf games-island.eu
    
    Verf√ºgbare Produkte:
    - Statusindikator "AUF LAGER"
    - Gr√ºner "Sofort verf√ºgbar"-Text
    - Gr√ºner "In den Warenkorb"-Button
    
    Nicht verf√ºgbare Produkte:
    - "Momentan nicht verf√ºgbar" in roter Schrift
    - "Benachrichtigung anfordern"-Button
    """
    # Pr√ºfe auf "Momentan nicht verf√ºgbar"-Text
    unavailable_text = soup.find(string=re.compile("Momentan nicht verf√ºgbar", re.IGNORECASE))
    if unavailable_text:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return False, price, "‚ùå Ausverkauft (Momentan nicht verf√ºgbar)"
    
    # Pr√ºfe auf "Benachrichtigung anfordern"-Button
    notify_button = soup.find('button', string=re.compile("Benachrichtigung anfordern", re.IGNORECASE))
    if notify_button:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return False, price, "‚ùå Ausverkauft (Benachrichtigungsbutton)"
    
    # Pr√ºfe auf "AUF LAGER"-Status
    in_stock_badge = soup.find(string=re.compile("AUF LAGER", re.IGNORECASE))
    if in_stock_badge:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return True, price, "‚úÖ Verf√ºgbar (AUF LAGER-Badge)"
    
    # Pr√ºfe auf "Sofort verf√ºgbar"-Text
    available_text = soup.find(string=re.compile("Sofort verf√ºgbar", re.IGNORECASE))
    if available_text:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return True, price, "‚úÖ Verf√ºgbar (Sofort verf√ºgbar)"
    
    # Pr√ºfe auf "In den Warenkorb"-Button
    cart_button = soup.find('button', string=re.compile("In den Warenkorb", re.IGNORECASE))
    if cart_button:
        price = extract_price(soup, ['.price', '.product-price', '.current-price'])
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Button)"
    
    # Wenn keine der bekannten Muster zutrifft, generische Methode
    return check_generic(soup)

def check_gameware(soup):
    """
    Verbesserte Pr√ºfung der Verf√ºgbarkeit auf gameware.at
    
    Verf√ºgbare Produkte:
    - Text "lagernd, in 1-3 Werktagen bei dir"
    - Gr√ºner Status-Punkt
    - Gr√ºner "IN DEN WARENKORB"-Button
    
    Nicht verf√ºgbare Produkte:
    - Text "Bestellung momentan nicht m√∂glich"
    - Grauer "AUSVERKAUFT"-Button
    """
    # Extrahiere den Preis
    price = extract_price(soup, ['.price', '.product-price', '.price-box'])
    page_text = soup.get_text().lower()
    
    # WICHTIG: Pr√ºfe zuerst auf eindeutige Verf√ºgbarkeitsindikatoren
    
    # 1. Pr√ºfe auf "lagernd" oder Lieferzeit-Texte
    # Dies ist ein sehr starker Indikator f√ºr Verf√ºgbarkeit bei Gameware
    if re.search(r"lagernd|in 1-3 werktagen|verf√ºgbar", page_text):
        print(f"  üîç Gameware: 'lagernd' oder Lieferzeit-Text gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Lagernd-Text)"
    
    # 2. Pr√ºfe auf gr√ºnen Status-Indikator
    green_status = soup.select_one('.stock-state.success, .stock-state.available, .badge-success')
    if green_status:
        print(f"  üîç Gameware: Gr√ºner Status-Indikator gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Gr√ºner Status)"
    
    # 3. Pr√ºfe auf aktiven "IN DEN WARENKORB"-Button
    cart_button = soup.select_one('button:not(.disabled) .fa-shopping-cart, .btn-add-to-cart:not(.disabled)')
    if cart_button:
        print(f"  üîç Gameware: Aktiver Warenkorb-Button gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Button aktiv)"
    
    # 4. Explizite Pr√ºfung auf "IN DEN WARENKORB"-Text im Button
    cart_text_button = soup.find(string=re.compile("IN DEN WARENKORB", re.IGNORECASE))
    if cart_text_button and not soup.select_one('button.disabled, [disabled]'):
        print(f"  üîç Gameware: 'IN DEN WARENKORB'-Text gefunden", flush=True)
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Text vorhanden)"
    
    # Jetzt erst auf Nicht-Verf√ºgbarkeit pr√ºfen
    
    # 5. Pr√ºfe auf "Bestellung momentan nicht m√∂glich"-Text
    unavailable_text = soup.find(string=re.compile("Bestellung momentan nicht m√∂glich", re.IGNORECASE))
    if unavailable_text:
        print(f"  üîç Gameware: 'Bestellung momentan nicht m√∂glich'-Text gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Bestellung nicht m√∂glich)"
    
    # 6. Pr√ºfe auf orangefarbenen/roten Status-Indikator
    warning_status = soup.select_one('.stock-state.warning, .stock-state.unavailable, .badge-danger')
    if warning_status:
        print(f"  üîç Gameware: Warnungs-Status-Indikator gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Warnungs-Status)"
    
    # 7. Pr√ºfe auf "ausverkauft"-Text oder Badge
    if "ausverkauft" in page_text:
        print(f"  üîç Gameware: 'ausverkauft' im Seitentext gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Text im Seiteninhalt)"
    
    # 8. Pr√ºfe auf "nicht verf√ºgbar"-Text
    if "nicht verf√ºgbar" in page_text:
        print(f"  üîç Gameware: 'nicht verf√ºgbar' im Seitentext gefunden", flush=True)
        return False, price, "‚ùå Ausverkauft (Nicht verf√ºgbar)"
    
    # Wenn keine der bekannten Muster zutrifft, generische Methode
    print(f"  üîç Gameware: Keine eindeutigen Indikatoren gefunden, verwende generische Methode", flush=True)
    return check_generic(soup)

def check_generic(soup):
    """
    Generische Methode zur Verf√ºgbarkeitspr√ºfung, die auf verschiedenen Websites funktioniert
    
    Diese Methode verwendet allgemeine Muster, die auf vielen E-Commerce-Seiten zu finden sind.
    """
    page_text = soup.get_text().lower()
    
    # Extraiere den Preis
    price = extract_price(soup)
    
    # Pr√ºfe auf eindeutige Nichtverf√ºgbarkeits-Signale
    unavailable_patterns = [
        'ausverkauft', 'sold out', 'out of stock', 'nicht verf√ºgbar', 
        'nicht auf lager', 'vergriffen', 'derzeit nicht verf√ºgbar',
        'momentan nicht', 'benachrichtigen'
    ]
    
    for pattern in unavailable_patterns:
        if pattern in page_text:
            return False, price, f"‚ùå Ausverkauft (Muster: '{pattern}')"
    
    # Suche nach Add-to-Cart / Buy-Buttons als positives Signal
    available_buttons = soup.select('button[type="submit"], input[type="submit"], .add-to-cart, .buy-now, #AddToCart, .product-form__cart-submit')
    has_add_button = len(available_buttons) > 0 and not any(
        'disabled' in str(btn) or 'ausverkauft' in btn.get_text().lower() or 'sold out' in btn.get_text().lower()
        for btn in available_buttons
    )
    
    # Pr√ºfe auf "Vorbestellbar" oder "Pre-order" als Form der Verf√ºgbarkeit
    preorder_patterns = ['vorbestellbar', 'vorbestellung', 'pre-order', 'preorder']
    is_preorder = any(pattern in page_text for pattern in preorder_patterns)
    
    # Pr√ºfe auf Verf√ºgbarkeitshinweise
    available_patterns = ['auf lager', 'verf√ºgbar', 'available', 'in stock', 'lieferbar']
    has_available_text = any(pattern in page_text for pattern in available_patterns)
    
    # Entscheidungslogik
    if has_add_button and not any(pattern in page_text for pattern in unavailable_patterns):
        return True, price, "‚úÖ Verf√ºgbar (Warenkorb-Button vorhanden)"
    elif is_preorder:
        return True, price, "üîú Vorbestellbar"
    elif has_available_text:
        return True, price, "‚úÖ Verf√ºgbar (Verf√ºgbarkeitstext)"
    else:
        return False, price, "‚ùì Status unbekannt"